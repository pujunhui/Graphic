## 返回值引用符号的使用规则

### 1. **必须使用引用返回的情况**

#### **赋值运算符 (`operator=`)**
```cpp
Vector2<T>& operator=(const Vector3<T>& v)
{
    x = v.x;
    y = v.y;
    return *this;  // 返回引用，支持链式赋值
}
```
- **原因**：支持链式赋值 `a = b = c`
- **返回对象**：当前对象的引用 `*this`

#### **复合赋值运算符 (`+=`, `-=`, `*=`, `/=`)**
```cpp
Vector2<T>& operator+=(const Vector2<T>& v)
{
    x += v.x;
    y += v.y;
    return *this;  // 返回引用，支持链式操作
}
```
- **原因**：支持链式操作 `a += b += c`
- **返回对象**：当前对象的引用 `*this`

#### **下标运算符 (非const版本)**
```cpp
T& operator[](int i)
{
    assert(i >= 0 && i < 2);
    if (i == 0) return x;
    return y;  // 返回引用，允许修改元素
}
```
- **原因**：允许通过下标修改向量元素 `v[0] = 5`
- **返回对象**：对应元素的引用

### 2. **不能使用引用返回的情况**

#### **算术运算符 (`+`, `-`, `*`, `/`)**
```cpp
Vector2<T> operator+(const Vector2<T>& v) const
{
    return Vector2(x + v.x, y + v.y);  // 返回新对象，不是引用
}
```
- **原因**：返回的是新创建的对象，不是现有对象的引用
- **如果返回引用**：会导致悬空引用，因为局部对象在函数结束时被销毁

#### **一元运算符 (`-`)**
```cpp
Vector2<T> operator-()
{
    return Vector2(-x, -y);  // 返回新对象
}
```
- **原因**：返回的是新创建的对象

#### **下标运算符 (const版本)**
```cpp
T operator[](int i) const
{
    assert(i >= 0 && i < 2);
    if (i == 0) return x;
    return y;  // 返回值，不允许修改
}
```
- **原因**：const函数不允许修改对象，返回值而不是引用

### 3. **特殊情况的引用返回**

#### **流运算符**
```cpp
friend std::ostream& operator<<(std::ostream& os, const Vector2& v) {
    os << "Vector2(" << v.x << ", " << v.y << ")";
    return os;  // 返回流对象的引用
}
```
- **原因**：支持链式输出 `cout << v1 << v2 << endl`
- **返回对象**：流对象的引用

## 总结

**使用引用返回的原则**：
1. **修改当前对象**的运算符（`=`, `+=`, `-=`, `*=`, `/=`）
2. **需要支持链式操作**的运算符
3. **返回现有对象引用**的运算符（如非const下标运算符）

**不使用引用返回的原则**：
1. **返回新创建对象**的运算符（`+`, `-`, `*`, `/`, 一元`-`）
2. **const函数**中不允许修改对象的运算符
3. **局部对象**在函数结束时会被销毁的情况

这样的设计既保证了性能（避免不必要的拷贝），又确保了内存安全和语义正确性。