# 插值算法详解

## 1. 直线插值算法

### 线性插值原理

线性插值是在两个已知数据点之间进行数值估计的方法。给定两个点 $(x_0, y_0)$ 和 $(x_1, y_1)$，可以计算它们之间任意点的值。

### 数学公式推导

#### 基本公式

对于线性函数，我们有：
$$y = kx + b$$

其中斜率为：
$$k = \frac{y_1 - y_0}{x_1 - x_0}$$

将点 $(x_0, y_0)$ 代入得到截距：
$$b = y_0 - kx_0 = y_0 - \frac{y_1 - y_0}{x_1 - x_0} \cdot x_0$$

因此，任意点x处的y值为：
$$y = \frac{y_1 - y_0}{x_1 - x_0}(x - x_0) + y_0$$

#### 参数化形式

引入参数 $t$：
$$t = \frac{x - x_0}{x_1 - x_0}$$

当 $t = 0$ 时，$x = x_0$；当 $t = 1$ 时，$x = x_1$。

线性插值公式可以写成：
$$y = y_0 + (y_1 - y_0) \cdot t$$

或等价形式：
$$y = (1-t)y_0 + ty_1$$

### C++实现

```cpp
template<typename T>
T linearInterpolate(T start, T end, float t) {
    return start + (end - start) * t;
}

// 基于坐标的线性插值
template<typename T>
T linearInterpolateByX(T start, T end, float x0, float x1, float x) {
    if (x1 == x0) return start;  // 避免除零
    float t = (x - x0) / (x1 - x0);
    return linearInterpolate(start, end, t);
}
```

### 应用场景

- 颜色渐变
- 纹理坐标插值
- 深度值插值
- 法向量插值

## 2. 三角形重心插值算法

### 重心坐标系统

重心坐标是一种用三个权重 $(\alpha, \beta, \gamma)$ 来表示三角形内任意点的坐标系统，其中：

$$\alpha + \beta + \gamma = 1$$

任意点P可以表示为：
$$\mathbf{P} = \alpha \mathbf{A} + \beta \mathbf{B} + \gamma \mathbf{C}$$

### 几何意义与数学推导

#### 面积坐标

对于三角形ABC内的点P，重心坐标具有明确的几何意义：

$$\alpha = \frac{S_{PBC}}{S_{ABC}}, \quad \beta = \frac{S_{PCA}}{S_{ABC}}, \quad \gamma = \frac{S_{PAB}}{S_{ABC}}$$

其中 $S_{XYZ}$ 表示三角形XYZ的面积。

#### 面积计算公式

使用叉积计算三角形面积：
$$S_{ABC} = \frac{1}{2}|(\mathbf{B} - \mathbf{A}) \times (\mathbf{C} - \mathbf{A})|$$

在二维情况下：
$$S_{ABC} = \frac{1}{2}|(x_B - x_A)(y_C - y_A) - (x_C - x_A)(y_B - y_A)|$$

#### 重心坐标的线性方程组

设三角形顶点为 $\mathbf{A} = (x_A, y_A)$，$\mathbf{B} = (x_B, y_B)$，$\mathbf{C} = (x_C, y_C)$，点P为 $(x_P, y_P)$。

由重心坐标定义：
$$\begin{cases}
x_P = \alpha x_A + \beta x_B + \gamma x_C \\
y_P = \alpha y_A + \beta y_B + \gamma y_C \\
\alpha + \beta + \gamma = 1
\end{cases}$$

写成矩阵形式：
$$\begin{bmatrix}
x_A & x_B & x_C \\
y_A & y_B & y_C \\
1 & 1 & 1
\end{bmatrix}
\begin{bmatrix}
\alpha \\
\beta \\
\gamma
\end{bmatrix} =
\begin{bmatrix}
x_P \\
y_P \\
1
\end{bmatrix}$$

#### 克拉默法则求解
使用克拉默法则求解重心坐标：

$$\alpha = \frac{\det\begin{bmatrix}
x_P & x_B & x_C \\
y_P & y_B & y_C \\
1 & 1 & 1
\end{bmatrix}}{\det\begin{bmatrix}
x_A & x_B & x_C \\
y_A & y_B & y_C \\
1 & 1 & 1
\end{bmatrix}}$$

$$\beta = \frac{\det\begin{bmatrix}
x_A & x_P & x_C \\
y_A & y_P & y_C \\
1 & 1 & 1
\end{bmatrix}}{\det\begin{bmatrix}
x_A & x_B & x_C \\
y_A & y_B & y_C \\
1 & 1 & 1
\end{bmatrix}}$$

$$\gamma = \frac{\det\begin{bmatrix}
x_A & x_B & x_P \\
y_A & y_B & y_P \\
1 & 1 & 1
\end{bmatrix}}{\det\begin{bmatrix}
x_A & x_B & x_C \\
y_A & y_B & y_C \\
1 & 1 & 1
\end{bmatrix}}$$

### 重心坐标计算方法

#### 方法一：面积比法
```cpp
struct Vector2 {
    float x, y;
    Vector2(float x = 0, float y = 0) : x(x), y(y) {}
    Vector2 operator-(const Vector2& other) const {
        return Vector2(x - other.x, y - other.y);
    }
};

// 计算三角形面积（使用叉积）
float triangleArea(const Vector2& a, const Vector2& b, const Vector2& c) {
    return 0.5f * abs((b.x - a.x) * (c.y - a.y) - (c.x - a.x) * (b.y - a.y));
}

// 计算重心坐标
Vector3 getBarycentricCoords(const Vector2& p, 
                            const Vector2& a, 
                            const Vector2& b, 
                            const Vector2& c) {
    float areaABC = triangleArea(a, b, c);
    
    if (areaABC < 1e-6f) {
        // 退化三角形
        return Vector3(1.0f, 0.0f, 0.0f);
    }
    
    float areaPBC = triangleArea(p, b, c);  // α 权重对应的面积
    float areaPCA = triangleArea(p, c, a);  // β 权重对应的面积
    float areaPAB = triangleArea(p, a, b);  // γ 权重对应的面积
    
    float alpha = areaPBC / areaABC;
    float beta = areaPCA / areaABC;
    float gamma = areaPAB / areaABC;
    
    return Vector3(alpha, beta, gamma);
}
```

#### 方法二：向量法推导

设向量：
$$\mathbf{v_0} = \mathbf{C} - \mathbf{A}, \quad \mathbf{v_1} = \mathbf{B} - \mathbf{A}, \quad \mathbf{v_2} = \mathbf{P} - \mathbf{A}$$

我们要找到标量 $u, v$ 使得：
$$\mathbf{v_2} = u\mathbf{v_0} + v\mathbf{v_1}$$

这等价于求解线性方程组：
$$\mathbf{P} - \mathbf{A} = u(\mathbf{C} - \mathbf{A}) + v(\mathbf{B} - \mathbf{A})$$

重心坐标为：
$$\alpha = 1 - u - v, \quad \beta = v, \quad \gamma = u$$

#### 点积方程组
将向量方程两边分别与 $\mathbf{v_0}$ 和 $\mathbf{v_1}$ 做点积：

$$\begin{cases}
\mathbf{v_2} \cdot \mathbf{v_0} = u(\mathbf{v_0} \cdot \mathbf{v_0}) + v(\mathbf{v_1} \cdot \mathbf{v_0}) \\
\mathbf{v_2} \cdot \mathbf{v_1} = u(\mathbf{v_0} \cdot \mathbf{v_1}) + v(\mathbf{v_1} \cdot \mathbf{v_1})
\end{cases}$$

设：
$$\text{dot}_{00} = \mathbf{v_0} \cdot \mathbf{v_0}, \quad \text{dot}_{01} = \mathbf{v_0} \cdot \mathbf{v_1}, \quad \text{dot}_{11} = \mathbf{v_1} \cdot \mathbf{v_1}$$
$$\text{dot}_{02} = \mathbf{v_0} \cdot \mathbf{v_2}, \quad \text{dot}_{12} = \mathbf{v_1} \cdot \mathbf{v_2}$$

线性方程组为：
$$\begin{bmatrix}
\text{dot}_{00} & \text{dot}_{01} \\
\text{dot}_{01} & \text{dot}_{11}
\end{bmatrix}
\begin{bmatrix}
u \\
v
\end{bmatrix} = 
\begin{bmatrix}
\text{dot}_{02} \\
\text{dot}_{12}
\end{bmatrix}$$

#### 克拉默法则求解
行列式：
$$D = \text{dot}_{00} \cdot \text{dot}_{11} - \text{dot}_{01}^2$$

解为：
$$u = \frac{\text{dot}_{11} \cdot \text{dot}_{02} - \text{dot}_{01} \cdot \text{dot}_{12}}{D}$$
$$v = \frac{\text{dot}_{00} \cdot \text{dot}_{12} - \text{dot}_{01} \cdot \text{dot}_{02}}{D}$$

因此重心坐标为：
$$\gamma = u, \quad \beta = v, \quad \alpha = 1 - u - v$$

```cpp
Vector3 getBarycentricCoords2(const Vector2& p, 
                             const Vector2& a, 
                             const Vector2& b, 
                             const Vector2& c) {
    Vector2 v0 = c - a;
    Vector2 v1 = b - a;
    Vector2 v2 = p - a;
    
    float dot00 = v0.x * v0.x + v0.y * v0.y;
    float dot01 = v0.x * v1.x + v0.y * v1.y;
    float dot02 = v0.x * v2.x + v0.y * v2.y;
    float dot11 = v1.x * v1.x + v1.y * v1.y;
    float dot12 = v1.x * v2.x + v1.y * v2.y;
    
    float invDenom = 1.0f / (dot00 * dot11 - dot01 * dot01);
    float beta = (dot11 * dot02 - dot01 * dot12) * invDenom;
    float gamma = (dot00 * dot12 - dot01 * dot02) * invDenom;
    float alpha = 1.0f - beta - gamma;
    
    return Vector3(alpha, beta, gamma);
}
```

### 属性插值
```cpp
template<typename T>
T barycentricInterpolate(const T& valueA, const T& valueB, const T& valueC,
                        const Vector3& baryCoords) {
    return valueA * baryCoords.x + valueB * baryCoords.y + valueC * baryCoords.z;
}

// 使用示例
Vector3 interpolateColor(const Vector2& p,
                        const Vector2& a, const Vector2& b, const Vector2& c,
                        const Vector3& colorA, const Vector3& colorB, const Vector3& colorC) {
    Vector3 baryCoords = getBarycentricCoords(p, a, b, c);
    return barycentricInterpolate(colorA, colorB, colorC, baryCoords);
}
```

### 判断点是否在三角形内
```cpp
bool isPointInTriangle(const Vector2& p, 
                      const Vector2& a, 
                      const Vector2& b, 
                      const Vector2& c) {
    Vector3 baryCoords = getBarycentricCoords(p, a, b, c);
    return baryCoords.x >= 0 && baryCoords.y >= 0 && baryCoords.z >= 0;
}
```

## 完整的三角形光栅化示例

```cpp
class TriangleRasterizer {
public:
    struct Vertex {
        Vector2 position;
        Vector3 color;
        Vector2 texCoord;
        float depth;
    };
    
    void rasterizeTriangle(const Vertex& v0, const Vertex& v1, const Vertex& v2) {
        // 计算包围盒
        int minX = (int)std::min({v0.position.x, v1.position.x, v2.position.x});
        int maxX = (int)std::max({v0.position.x, v1.position.x, v2.position.x});
        int minY = (int)std::min({v0.position.y, v1.position.y, v2.position.y});
        int maxY = (int)std::max({v0.position.y, v1.position.y, v2.position.y});
        
        // 遍历包围盒内的每个像素
        for (int y = minY; y <= maxY; y++) {
            for (int x = minX; x <= maxX; x++) {
                Vector2 p(x + 0.5f, y + 0.5f);  // 像素中心点
                
                // 计算重心坐标
                Vector3 baryCoords = getBarycentricCoords(p, 
                    v0.position, v1.position, v2.position);
                
                // 检查是否在三角形内
                if (baryCoords.x >= 0 && baryCoords.y >= 0 && baryCoords.z >= 0) {
                    // 插值顶点属性
                    Vector3 color = barycentricInterpolate(
                        v0.color, v1.color, v2.color, baryCoords);
                    
                    Vector2 texCoord = barycentricInterpolate(
                        v0.texCoord, v1.texCoord, v2.texCoord, baryCoords);
                    
                    float depth = barycentricInterpolate(
                        v0.depth, v1.depth, v2.depth, baryCoords);
                    
                    // 深度测试和像素着色
                    if (depthTest(x, y, depth)) {
                        setPixel(x, y, color);
                    }
                }
            }
        }
    }
    
private:
    virtual bool depthTest(int x, int y, float depth) = 0;
    virtual void setPixel(int x, int y, const Vector3& color) = 0;
};
```

## 应用场景

### 图形学应用
1. **三角形光栅化**：3D渲染中的基础操作
2. **纹理映射**：插值纹理坐标
3. **Gouraud着色**：顶点颜色的平滑插值
4. **深度插值**：Z-buffer深度测试

### 物理仿真
1. **有限元分析**：在三角网格上插值物理量
2. **流体仿真**：插值速度和压力场
3. **温度场分析**：热传导仿真中的温度插值

## 性能优化

### 增量式计算
```cpp
// 对于连续的像素点，可以使用增量式计算重心坐标
class IncrementalBarycentrics {
    float alpha, beta, gamma;
    float alphaStepX, betaStepX, gammaStepX;
    float alphaStepY, betaStepY, gammaStepY;
    
public:
    void setupRow(int y, const Vector2& a, const Vector2& b, const Vector2& c);
    void stepX();
    Vector3 getCurrentCoords() const { return Vector3(alpha, beta, gamma); }
};
```

### 边界优化
通过提前计算三角形的边界信息，可以避免对明显在三角形外的像素进行重心坐标计算。

